[{"title":"常见清除浮动方法总结","date":"2017-05-07T01:45:47.000Z","path":"2017/05/07/常见清除浮动方法总结/","text":"清除浮动方法总结浮动(float)，可以很优雅的让原本独立傲娇的块级元素和谐的站立于同一行，但是，同时这也引起了父容器的塌方，造成页面布局的混乱，so，清除浮动在这个时候就显得很必要！ 方法一：使用overflow属性原理：找到浮动元素的父元素，在父元素的样式中添加一个属性overflow:hidden;优点：简单，浏览器支持性好缺点：不能和position配合使用，超出的尺寸会被隐藏 方法二：添加空标签12345678910111213&lt;style&gt; .d1&#123;width:100px;height:100px;background:#f00;float:left&#125; .d2&#123;width:200px;height:200px;background:#0f0;float:right&#125; .clear&#123;clear:both&#125;&lt;/style&gt;&lt;div&gt; &lt;div class = \"d1\"&gt;left&lt;/div&gt; &lt;div class = \"d2\"&gt;ringt&lt;/div&gt; &lt;div class = \"clear\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt; div2&lt;/div&gt; 原理：在浮动元素下面添加一个空div,设置该标签样式clear:both;来清除浮动对页面的影响优点：代码少，浏览器支持性好，不易出现怪问题缺点：若页面很多浮动，会增加很多无意义的div，不爽😕 方法三：使用伪元素清除浮动123456789101112131415161718&lt;style&gt; .d1&#123;width:100px;height:100px;background:#f00;float:left&#125; .d2&#123;width:200px;height:200px;background:#0f0;float:right&#125; .div1:after&#123; content:\"\"; height:0; display:block; visibility:hidden; clear:both; &#125; .div1&#123; zoom:1;//为了兼容IE； &#125;&lt;/style&gt;&lt;div class=\"div1\"&gt; &lt;div class = \"d1\"&gt;left&lt;/div&gt; &lt;div class = \"d2\"&gt;ringt&lt;/div&gt; &lt;/div&gt; 原理：与方法二有点类似，IE8及非IE浏览器才支持:after属性，zoom可解决IE6，IE7浮动问题优点：浏览器支持性好，不易出现怪问题😄缺点：代码多，需要考虑到兼容性 总结 就此三种清除浮动方式的优缺点来看，本姑娘强烈推荐使用方式三、方式三、方式三！！！ 如果overflow:hidden;您能玩的很溜的话，方式一也可以随便用； 如果您有海量，能容忍大量的无意义div的存在,方法三也会成为你的得力助手😜","tags":[{"name":"笔记","slug":"笔记","permalink":"http://cynthia1028.me/tags/笔记/"}]},{"title":"说说flex布局","date":"2017-04-24T03:08:59.000Z","path":"2017/04/24/说说flex布局/","text":"Flex是Flexible Box的缩写，即为“弹性布局”的意思Flex布局，可以简便、完整、响应式地实现各种页面的布局任何容器都可以为Flex布局： 通常：.box{display: flex;} 行内元素：.box{display: inline-flex;} Webkit内核的浏览器: 1234.box&#123; display: -webkit-flex;/*Safari*/ display: flex;&#125; 注意，设定为Flex布局以后，子元素的float，clear和vertical-align属性将失效。 属性使用说明1234567891011121314151617181920212223242526272829/*容器属性*/.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式：左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125;/*项目属性*/.item&#123; order: &lt;integer&gt;; /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，两个快捷值：auto(1 1 auto),none(0 0 auto)*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 对于经常出现像这样的样式语句flex:1;有如下解释：当flex取值为一个非负数字，则该数字为flex-grow 值 123456.item&#123;flex: 1&#125;;.item&#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; 当flex取值为一个长度或百分比，则视为flex-basis值 123456789101112.item-1&#123;flex: 0%;&#125;.item-1&#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125;.item-2&#123;flex: 24px;&#125;.item-2&#123; flex-grow: 1; flex-shrink: 1; flex-basis: 24px;&#125; 当flex取值为两个非负数字，则分别视为flex-grow和flex-shrink的值，flex-basis取0%当flex取值为一个非负数字和一个长度或百分比，则分别视为flex-grow和flex-basis的值，flex-shrink取1 开心😄的看完flex的语法，觉得flex的出现简直就是前端的救星呀，不过，如果要考虑到前端的祖宗浏览器（IE6，7，8，9）的兼容性问题的话，我们只能欲哭无泪呀😢","tags":[{"name":"笔记","slug":"笔记","permalink":"http://cynthia1028.me/tags/笔记/"}]},{"title":"浅谈前端浏览器兼容性","date":"2017-04-18T03:08:43.000Z","path":"2017/04/18/浅谈前端浏览器兼容性/","text":"经过千百次的百度，Google终于对传说中的浏览器兼容性有了稍微系统一点的认识💃💃💃简单阐述一下所谓的系统认知： css兼容1.盒模型差异解决：*{margin:0;padding:0}2.IE6 margin加倍div float后，并设置了横向的margin，IE6显示margin比设置的大解决：在float的标签样式控制中加入display:inline;3.IE6最小高度IE6不支持min-height属性，默认height为最小高度解决：使用IE6不支持但其余浏览器支持的属性!importanteg:设置一个div的最小高度为200px 12345div&#123; min-height:200px; height:auto !important; height:200px;&#125; 4.高度问题设置较小高度标签（小于10px），IE6、7不受控制，超出自己设置高度解决：给超出高度的标签设置overflow:hidden;font-size:高度；5.双倍边距行内属性标签设置display:block后，采用float布局，又有横向margin，IE6中会出现双倍边距 1234567.divBox&#123; float:left; width:100px; margin:0 0 0 100px; //ie6下会产生200px的边距 display:inline;//使浮动忽略，但高度不可设置了 display:table;&#125; 6.image标签-图片存在边距几个img标签放在一起，有些浏览器会有默认的间距，加了*{margin:0px;padding:0px;}的通配符也不起作用解决：用float为img布局7.ul和li列表缩进解决:12345ul,ol&#123; margin:0px; padding:0px; list-style:none;&#125; 8.a标签css顺序被点击过后的超链接不再具有hover和active属性解决：按lvha顺序书写css9.透明度解决:12opacity:0.8;//通用filter:alpha(opacity=80);//IE 10.水平居中IE6下使用margin:0 auto;无法使其居中解决：为其父元素设置text-align:center;11.垂直居中在浏览器中设置vertical-align:middle;不起作用。解决：line-height:与容器的height一样;12.对于一些CSS3属性，会有浏览器的兼容问题，需要添加浏览器引擎前缀去匹配需添加浏览器引擎前缀的属性： @keyframes 移动和变换属性(transition-property, transition-duration, transition-timing-function, transition-delay) 动画属性 (animation-name, animation-duration, animation-timing-function, animation-delay) border-radius box-shadow backface-visibility column属性 flex属性 perspective属性…… eg: 1234567.myClass &#123; -webkit-animation-name: fadeIn; -moz-animation-name: fadeIn; -o-animation-name: fadeIn; -ms-animation-name: fadeIn; animation-name: fadeIn; /* 不带前缀的放到最后 */&#125; CSS hack1.IE条件注释语法：123&lt;!--[if &lt;keywords&gt;? IE &lt;version&gt;?]&gt; /*keywords取值：空；gt；gte；lt；lte；！*／满足条件要执行的代码&lt;![endif]--&gt; 2.属性过滤器\\9 ie10之前的ie浏览器解析的代码+或者* 表示ie7包括7之前的ie浏览器_表示 ie6包括6之前的ie浏览器eg：12345.test &#123; color: #090\\9; /* For IE8+ */*color: #f00; /* For IE7 and earlier */_color: #ff0; /* For IE6 and earlier */&#125; 文字码到这里瞬间觉得很有必要积累一个属于自己的reset.css 📒结合自己的经验尽量避免出现不兼容问题 JS兼容1.集合类对象IE可以使用()或[]获取集合类对象，而Firefox只能用[]获取解决：统一使用[]获取集合类对象2.通过ID获取元素12Firefox:document.getElementById(\"idName\"); IE：document.idname或者document.getElementById(\"idName\"); 解决：统一使用document.getElementById(&quot;idName&quot;);3.常量定义Firefox:可以使用const或var关键字来定义常量IE:只能使用var关键字来定义解决:统一使用var关键字来定义常量4.input.type属性IE:input.type属性为只读Firefox:input.type属性为读写解决:尽量避免修改input类型，若必须修改，可以先隐藏原来的input，然后在同样的位置插入一个新的input5.事件监听DOM标准:elem.addEventlistener()IE8:elem.attachEvent()解决：12345678function addEvent(elem, eventName, handler) &#123; if (elem.attachEvent) &#123; elem.attachEvent(\"on\" + eventName,function()&#123; handler.call(elem)&#125;); //此处使用回调函数call()，让this指向elem &#125; else if (elem.addEventListener) &#123; elem.addEventListener(eventName, handler, false); &#125;&#125; 6.事件对象DOM标准：事件对象作为事件处理函数第一个参数传入函数中argumnets[0]IE:事件对象是window下的一个全局属性 window.event解决: 1var e=window.event || arguments[0] 7.阻止事件冒泡DOM标准:e.stopPropagation()IE:e.cancelBubble=true解决: 12345if(e.stopPropagation)&#123; e.stopPropagation();&#125;else&#123; e.cancelBubble=true;&#125; 8.获取目标元素解决:var target = e.target || e.srcElement前者是DOM标准下的，后者是IE下的9.阻止默认行为解决：12345if(e.preventDefault)&#123; e.preventDefault();//DOM&#125;else&#123; e.returnValue=false;//IE&#125; 10.滚动条解决：1document.documentElement.scrollTop || document.body.scrollTop 前者是DOM标准下的写法，后者是IE11.坐标解决:1234var page = &#123;&#125;;page.x = event.x ? event.x : event.pageX;page.y = event.y ? event.y:event.pageY;//event的x,y在IE中支持，pageX和pageY在Firefox中支持 12.键盘事件解决: function getKeyCode(e){ //兼容IE和Firefox获得keyBoardEvent对象 e = e ? e : (window.event ? window.event : &quot;&quot;) //兼容IE和Firefox获得keyBoardEvent对象的键值 return e.keyCode ? e.keyCode : e.which; } //IE：e.keyCode //fireFox: e.which 以上仅仅是本人学习过程中碰到的，包括网上参考别人整理的，目前只收录这么多，后期如有补充会及时收录！📝","tags":[{"name":"笔记","slug":"笔记","permalink":"http://cynthia1028.me/tags/笔记/"}]},{"title":"走进Benqio","date":"2017-04-14T02:33:29.000Z","path":"2017/04/14/走进Benqio/","text":"——畅聊和一帮爷们一起奋斗的第一个月 一个月，对于行业的了解逐渐由混沌变得清晰前三个礼拜，纯粹穷忙找不到工作重点，东一榔头西一棒庆幸的是居然每天感觉还很充实应该是新鲜感、好奇心所主导这个星期，能够自我设定明确目标，并为之努力💪这就是时间的的神奇。 浑浑噩噩走过的路： 埋头苦读typescript文档 学习angular2（半途而废，底子薄弱，看不懂，很无奈🤷‍♀️） 竭尽全力了解所谓的工作流（居然还be pround of it） 知晓了grafana、vue-echars-v3、仪表盘adminLte模版的存在（很惭愧现在就只是对这几个单词眼熟而已）…… 看过美丽炫酷的web页面总想人机交互更友好我的天，一个“更”字能够要了我这种患有严重强迫症的人半条老命算了，管不了那么多的planA、B、C…😭这还是我心心念念一直大爱的前端么？ 如梦初醒：空洞的理论学习不大适合脑袋不灵光的我找个项目下手吧，也许这才是条明路！隔壁邻座的耿直boy自然成了我的现实版度娘👍 1.先了解bootstrap-table框架、arttemplate以及seajs的基本用法（混个面熟，看到 不至于一脸懵逼样😳）2.捋清楚整个项目的大体轮廓，选择一个页面模块深入理解3.找到相关页面的代码，通过看、查、问，达到阶段小目标：懂4.归纳整理 学会阅读bootstrap-table官方文档，根据example会运用到实例中 学习layer、jquerysteps等小插件的使用 了解jquery的一些特殊的语法应用，并加以特别记忆 多看几遍，越来越觉得这些大段大段黑压压的代码可爱了😊 Oh,how time flies!我得去挺尸了明天得继续两眼放光的看我那可爱的代码呢！ 晚安，我爱的Soochow！ 4月13日深夜于安静卧室","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cynthia1028.me/tags/随笔/"}]},{"title":"JavaScript知识点复习之作用域、作用域链及闭包","date":"2017-01-09T13:31:18.000Z","path":"2017/01/09/JavaScript知识点复习之作用域、作用域链及闭包/","text":"1 作用域 JavaScript中的函数作用域是指：变量在声明它的函数体以及这个函数体嵌套的任意函数体内都是有定义的。函数体内声明的所有变量（不涉及到赋值）都被提前至函数的顶部声明，这种特性也被称为“声明提前”。 123456function test()&#123; console.log(x); //undefined var x = 10; console.log(x); //10&#125;test(); 全局变量拥有全局作用域，在JavaScript代码的任何地方都可以访问；在函数内部声明的变量只在函数体内有定义，即为局部变量，其作用是局部性的。Notice:在函数体内声明变量时，如果不使用 var 关键字，则将声明全局变量。 123456var x = \"global\";function test()&#123; var x = \"local\"; return x;&#125;console.log(test()); //local 2 作用域链 定义一个函数时(保存了一个作用域链）：创建两个对象————函数对象和全局对象 函数对象：封装了函数的定义，但暂时不读取函数定义。 全局对象：专门保存函数可用的变量所在位置的对象。 当一个函数被调用时：创建一个新对象————活动对象 活动对象：临时封装本次调用函数时使用的局部变量，并将活动对象的引用压入全局对象中。 当函数调用完成后：如果没有其他引用指向此次调用所创建的活动对象，该对象引用出栈，活动对象及其内部的局部变量一同释放。 举个例子： 1234567891011121314var name = \"one\";function test()&#123; var name = \"two\"; function test1()&#123; var name = \"three\"; console.log(name);//three &#125; function test2()&#123; console.log(name);//two &#125; test1(); test2();&#125;test(); 当成功调用test1()时，顺序为test1()-&gt;test()-&gt;全局对象window,因为在test1()上就找到了name的值three，所以完成搜索返回； 当成功调用test2()时，顺序为test2()-&gt;test()-&gt;全局对象window,因为在test2()上没找到name的值，所以找test()中的，找到了name的值two,就完成搜索返回。 3 闭包 判断闭包的特征： a. 函数嵌套； b. 内层函数使用外层函数的局部变量； c. 内层函数被返回到外部，在外部调用。 举个例子： 123456789var a = 100;function f()&#123; var a = 200; function g()&#123; return a; &#125; return g;&#125;console.log(f()());//200 上述代码意味着，先执行f(),得到该函数内嵌套的一个函数对象g,然后调用这个嵌套函数。 再来个例子，闭包的典型应用： 1234567891011var n = 10;function counter()&#123; var n = 0; var g = function ()&#123; return ++n; &#125;; return g;&#125;var c1 = counter();console.log(c1());//1console.log(c1());//2 何时使用：即要重用变量，又要保护变量不被污染。缺点：占用更多内存空间。 这只是对闭包一个浅浅的理解，后续还会深入透彻理解。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://cynthia1028.me/tags/笔记/"}]},{"title":"开启博客之旅","date":"2016-12-16T13:38:06.000Z","path":"2016/12/16/开启博客之旅/","text":"从听说H5到学习web前端，从阅读简书到开写博客，总该为每一次新的涉猎留下点脚印了……HELLO Blog!","tags":[{"name":"随笔","slug":"随笔","permalink":"http://cynthia1028.me/tags/随笔/"},{"name":"文艺","slug":"文艺","permalink":"http://cynthia1028.me/tags/文艺/"}]},{"title":"Hello World","date":"2016-12-16T13:14:44.000Z","path":"2016/12/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]